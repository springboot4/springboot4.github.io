### 类的加载

#### 类的加载过程(生命周期)

 在Java中数据类型分为基本数据类型和引用数据类型。基本数据类型由虚拟机预先定义，引用数据类型则需要进行类的加载。 

- 过程一: Loading(装载)阶段

  所谓装载，简而言之就是将Java类的字节码文件加载到机器内存中，并在内存中构建出Java类的原型——类模板对象。 装载完成的操作装载阶段，简言之，查找并加载类的二进制数据，生成Class的实例。在加载类时，Java虚拟机必须完成以下3件事情：通过类的全名，获取类的二进制数据流。解析类的二进制数据流为方法区内的数据结构（Java类模型）创建java.lang.Class类的实例，表示该类型。作为方法区这个类的各种数据的访问入口 

  - 什么是类模板对象

     所谓类模板对象，其实就是J**ava类在JVM内存中的一个快照**，JVM将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样JVM在运行期便能通过类模板而获取Java类中的任意信息，能够对Java类的成员变量进行遍历，也能进行Java方法的调用。 反射的机制即基于这一基础。如果JVM没有将Java类的声明信息存储起来，则JVM在运行期也无法反射。  

  - 二进制流有哪些获取方式

     对于类的二进制数据流，虚拟机可以通过多种途径产生或获得。（只要所读取的字节码符合JVM规范即可）虚拟机可能通过文件系统读入一个class后缀的文件（最常见）读入jar、zip等归档数据包，提取类文件。事先存放在数据库中的类的二进制数据使用类似于HTTP之类的协议通过网络进行加载在运行时生成一段Class的二进制信息等  

  - Class实例的位置在哪里

     类将.class文件加载至元空间后，会在堆中创建一个Java.lang.Class对象，用来封装类位于方法区内的数据结构，该Class对象是在加载类的过程中创建的，每个类都对应有一个Class类型的对象。(instanceKlass -->mirror :Class的实例) 图示外部可以通过访问代表Order类的Class对象来获取Order的类数据结构。

  - 数组类的加载有哪些不同

    数组类的加载创建数组类的情况稍微有些特殊，因为数组类本身并不是由类加载器负责创建，而是由JVM在运行时根据需要而直接创建的，但数组的元素类型仍然需要依靠类加载器去创建。

    创建数组类（下述简称A）的过程： 

    - 如果数组的元素类型是引用类型，那么就遵循定义的加载过程递归加载和创建数组A的元素类型；
    -  JVM使用指定的元素类型和数组维度来创建新的数组类。
    -  如果数组的元素类型是引用类型，数组类的可访问性就由元素类型的可访问性决定。否则数组类的可访问性将被缺省定义为public。 

- 过程二：Linking(链接)阶段

  - 链接阶段之Verification(验证)

     当类加载到系统后，就开始链接操作，验证是链接操作的第一步。 它的目的是保证加载的字节码是合法、合理并符合规范的。 验证的步骤比较复杂，实际要验证的项目也很繁多。整体说明：验证的内容则涵盖了类数据信息的格式验证、语义检查、字节码验证，以及符号引用验证等。其中格式验证会和装载阶段一起执行。验证通过之后，**类加载器才会成功将类的二进制数据信息加载到方法区中**。格式验证之外的验证操作将会在方法区中进行。  

  - 链接阶段之Preparation(准备)

     简言之，**为类的静态变量分配内存，并将其初始化为默认值。**在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置默认初始值。注意：Java并不支持boolean类型，对于boolean类型，内部实现是int,由于int的默认值是0,故对应的，boolean的默认值就是false。     

  - 链接阶段之Resolution(解析)

     简言之，**将类、接口、字段和方法的符号引用转为直接引用**。

     1.具体描述:符号引用就是一些字面量的引用，和虚拟机的内部数据结构和和内存布局无关。比较容易理解的就是在Class类文件中，通过常量池进行了大量的符号引用。但是在程序实际运行时，只有符号引用是不够的，比如当如下println()方法被调用时，系统需要明确知道该方法的位置。 

    举例：输出操作System.out.println()

    对应的字节码：invokevirtual #24 <java/io/PrintStream.println> 以方法为例，**Java虚拟机为每个类都准备了一张方法表，将其所有的方法都列在表中，当需要调用一个类的方法的时候，只要知道这个方法在方法表中的偏移量就可以直接调用该方法**。通过解析操作，符号引用就可以转变为目标方法在类中方法表中的位置，从而使得方法被成功调用。

     2.小结： **所谓解析就是将符号引用转为直接引用，也就是得到类、字段、方法在内存中的指针或者偏移量。**因此，可以说，如果直接引用存在，那么可以肯定系统中存在该类、方法或者字段。但只存在符号引用，不能确定系统中一定存在该结构。 不过Java虚拟机规范并没有明确要求解析阶段一定要按照顺序执行。在HotSpot VM中，加载、验证、准备和初始化会按照顺序有条不紊地执行，但链接阶段中的解析操作往往会伴随着JVM在执行完初始化之后再执行。   

- 过程三：Initialization(初始化)阶段

  - 子类加载前先加载父类？

     在加载一个类之前，虚拟机总是会试图加载该类的父类，因此父类的<clinit>总是在子类<clinit>之前被调用。也就是说，**父类的static块优先级高于子类。 口诀：由父及子，静态先行。** 

  - 哪些类不会生成<clinit>方法？

     Java编译器并不会为所有的类都产生<clinit>()初始化方法。哪些类在编译为字节码后，字节码文件中将不会包含<clinit>()方法？

    对于非静态的字段，不管是否进行了显式赋值，都不会生成<clinit>()方法

    静态的字段，没有显式的赋值，不会生成<clinit>()方法

    一个类中包含static final修饰的基本数据类型的字段，不管是否进行了显式赋值，都不会生成<clinit>()方法。

  - <clinit>()的调用会死锁吗

    对于<clinit>()方法的调用，也就是类的初始化，虚拟机会在内部确保其多线程环境中的安全性。 虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行<clinit>()方法完毕。 正是因为函数<clinit>()带锁线程安全的，因此，如果在一个类的<clinit>()方法中有耗时很长的操作，就可能造成多个线程阻塞，引发死锁。并且这种死锁是很难发现的，因为看起来它们并没有可用的锁信息。 如果之前的线程成功加载了类，则等在队列中的线程就没有机会再执行<clinit>()方法了。那么，当需要使用这个类时，虚拟机会直接返回给它已经准备好的信息。 

  - 类的初始化情况：主动使用vs被动使用

    Java程序对类的使用分为两种：主动使用 和 被动使用。

    主动使用的说明：Class只有在必须要首次使用的时候才会被装载，Java虚拟机不会无条件地装载Class类型。

    Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是指主动使用。

    主动使用只有下列几种情况：（即：如果出现如下的情况，则会对类进行初始化操作。而初始化操作之前的加载、验证、准备已经完成。）

    

    - 当创建一个类的实例时，比如使用new关键字，或者通过反射、克隆、反序列化。
    -  当调用类的静态方法时，即当使用了字节码invokestatic指令。
    -  当使用类、接口的静态字段时(final修饰特殊考虑)，比如，使用getstatic或者putstatic指令。
    -  当使用java.lang.reflect包中的方法反射类的方法时。比如：Class.forName("com.atguigu.java.Test")
    -  当初始化子类时，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。
    -  如果一个接口定义了default方法，那么直接实现或者间接实现该接口的类的初始化，该接口要在其之前被初始化。
    -  当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。
    -  当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。（涉及解析REF_getStatic、REF_putStatic、REF_invokeStatic方法句柄对应的类）  

     被动使用的情况除了以上的情况属于主动使用，其他的情况均属于被动使用。被动使用不会引起类的初始化。也就是说：并不是在代码中出现的类，就一定会被加载或者初始化。如果不符合主动使用的条件，类就不会初始化。

    - 当访问一个静态字段时，只有真正声明这个字段的类才会被初始化。当通过子类引用父类的静态变量，不会导致子类初始化
    -  通过数组定义类引用，不会触发此类的初始化
    -  **引用常量不会触发此类或接口的初始化。因为常量在链接阶段就已经被显式赋值了。**
    -  调用ClassLoader类的loadClass()方法加载一个类，并不是对类的主动使用，不会导致类的初始化。  被动的使用，意味着不需要执行初始化环节，意味着没有<clinit>()的调用。 

  - 使用static + final修饰的字段的显式赋值的操作，到底是在哪个阶段进行的赋值？

    1. 在链接阶段的准备环节赋值
    2.  在初始化阶段<clinit>()中赋值

    结论：

    - 在链接阶段的准备环节赋值的情况：

      1）对于基本数据类型的字段来说，如果使用static final修饰，则显式赋值(**直接赋值常量，而非调用方法**）通常是在**链接阶段**的准备环节进行

       2）对于String来说，如果使用**字面量**的方式赋值，使用static final修饰的话，则显式赋值通常是在**链接阶段**的准备环节进行。

    - 在初始化阶段<clinit>()中赋值的情况：

      排除上述的在准备环节赋值的情况之外的情况。

        **总结**: 使用static + final 修饰的成员变量，称为：全局常量。什么时候在链接阶段的准备环节：给此全局常量附的值是字面量或常量。**不涉及到方法或构造器的调用**。除此之外，都是在初始化环节赋值的。

- 过程四：类的Using(使用)

   任何一个类型在使用之前都必须经历过完整的加载、链接和初始化3个类加载步骤。一旦一个类型成功经历过这3个步骤之后，便“万事俱备，只欠东风”，就等着开发者使用了。 开发人员可以在程序中访问和调用它的静态类成员信息（比如：静态字段、静态方法），或者使用new关键字为其创建对象实例。   

- 过程五：类的Unloading(卸载)

  - 类、类的加载器、类的实例之间的关系

     **类、类的加载器、类的实例之间的引用关系在类加载器的内部实现中，用一个Java集合来存放所加载类的引用。**另一方面**，一个Class对象总是会引用它的类加载器，调用Class对象的getClassLoader()方法，就能获得它的类加载器**。由此可见，代表某个类的Class实例与其类的加载器之间为**双向关联关系**。 一个类的实例总是引用代表这个类的Class对象。在Object类中定义了getClass()方法，这个方法返回代表对象所属类的Class对象的引用。此外，所有的Java类都有一个静态属性class，它引用代表这个类的Class对象。  

  - 何种情况类会被卸载？

     一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。当Sample类被加载、链接和初始化后，它的生命周期就开始了。当代表Sample类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。 

    举例：loader1变量和obj变量间接引用代表Sample类的Class对象，而objClass变量则直接引用它。 如果程序运行过程中，将上图左侧三个引用变量都置为null，此时Sample对象结束生命周期，MyClassLoader对象结束生命周期，代表Sample类的Class对象也结束生命周期，Sample类在方法区内的二进制数据被卸载。 当再次有需要时，会检查Sample类的Class对象是否存在，如果存在会直接使用，不再重新加载；如果不存在Sample类会被重新加载，在Java虚拟机的堆区会生成一个新的代表Sample类的Class实例(可以通过哈希码查看是否是同一个实例)。 

  - 类卸载在实际生产中的情况如何？

    (1) 启动类加载器加载的类型在整个运行期间是不可能被卸载的(jvm和jls规范) 

    (2) 被系统类加载器和扩展类加载器加载的类型在运行期间不太可能被卸载，因为系统类加载器实例或者扩展类的实例基本上在整个运行期间总能直接或者间接的访问的到，其达到unreachable的可能性极小。

     (3) 被开发者自定义的类加载器实例加载的类型只有在很简单的上下文环境中才能被卸载，而且一般还要借助于强制调用虚拟机的垃圾收集功能才可以做到。可以预想，稍微复杂点的应用场景中(比如：很多时候用户在开发自定义类加载器实例的时候采用缓存的策略以提高系统性能)，被加载的类型在运行期间也是几乎不太可能被卸载的(至少卸载的时间是不确定的)。 

    综合以上三点，一个已经加载的类型被卸载的几率很小至少被卸载的时间是不确定的。同时我们可以看的出来，开发者在开发代码时候，不应该对虚拟机的类型卸载做任何假设的前提下，来实现系统中的特定功能。 

  - 拓展：方法区的垃圾回收

     方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型。

    HotSpot虚拟机对常量池的回收策略是很明确的，只要常量池中的常量没有被任何地方引用，就可以被回收。 判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。

    需要同时满足下面三个条件： 该类所有的实例都已经被回收。也就是Java堆中不存在该类及其任何派生子类的实例。 加载该类的类加载器已经被回收。这个条件除非是经过精心设计的可替换类加载器的场景，如OSGi、JSP的重加载等，否则通常是很难达成的。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 Java虚拟机被允许对满足上述三个条件的无用类进行回收，这里说的仅仅是“被允许”，而并不是和对象一样，没有引用了就必然会回收。  

#### 类的加载器

- 作用

   类加载器是 JVM 执行类加载机制的前提。

  ClassLoader的作用：ClassLoader是Java的核心组件，所有的Class都是由ClassLoader进行加载的，ClassLoader负责通过各种方式将Class信息的二进制数据流读入JVM内部，转换为一个与目标类对应的java.lang.Class对象实例。然后交给Java虚拟机进行链接、初始化等操作。 因此，ClassLoader在整个装载阶段，只能影响到类的加载，而无法通过ClassLoader去改变类的链接和初始化行为。至于它是否可以运行，则由Execution Engine决定。    

- 类加载的显式加载与隐式加载

  class文件的显式加载与隐式加载的方式是指JVM加载class文件到内存的方式。

  显式加载：指的是在代码中通过调用ClassLoader加载class对象，如直接使用Class.forName(name)或this.getClass().getClassLoader().loadClass()加载class对象。

  隐式加载：则是不直接在代码中调用ClassLoader的方法加载class对象，而是通过虚拟机自动加载到内存中，如在加载某个类的class文件时，该类的class文件中引用了另外一个类的对象，此时额外引用的类将通过JVM自动加载到内存中。 在日常开发以上两种方式一般会混合使用。 

- 类加载机制的必要性

  一般情况下，Java开发人员并不需要在程序中显式地使用类加载器，但是了解类加载器的加载机制却显得至关重要。

  从以下几个方面说： 

  避免在开发中遇到 java.lang.ClassNotFoundException异常或java.lang.NoClassDefFoundError异常时，手足无措。只有了解类加载器的加载机制才能够在出现异常的时候快速地根据错误异常日志定位问题和解决问题 

  需要支持类的动态加载或需要对编译后的字节码文件进行加解密操作时，就需要与类加载器打交道了。 开发人员可以在程序中编写自定义类加载器来重新定义类的加载规则，以便实现一些自定义的处理逻辑。  

- 加载的类是唯一的吗？

   1.何为类的唯一性？

  对于任意一个类，都需要由加载它的类加载器和这个类本身一同确认其在Java虚拟机中的唯一性。每一个类加载器，都拥有一个独立的类名称空间：比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类源自同一个Class文件，被同一个虚拟机加载，只要加载他们的类加载器不同，那这两个类就必定不相等。 

  2.命名空间

  每个类加载器都有自己的命名空间，命名空间由该加载器及所有的父加载器所加载的类组成，在同一命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类 在大型应用中，我们往往借助这一特性，来运行同一个类的不同版本。  

- 类加载机制的基本特征

   通常类加载机制有三个基本特征： 

  双亲委派模型。但不是所有类加载都遵守这个模型，有的时候，启动类加载器所加载的类型，是可能要加载用户代码的，比如JDK内部的ServiceProvider/ServiceLoader机制，用户可以在标准API框架上，提供自己的实现，JDK也需要提供些默认的参考实现。例如，Java 中JNDI、JDBC、文件系统、Cipher等很多方面，都是利用的这种机制，这种情况就不会用双亲委派模型去加载，而是利用所谓的上下文加载器。

   可见性。子类加载器可以访问父加载器加载的类型，但是反过来是不允许的。不然，因为缺少必要的隔离，我们就没有办法利用类加载器去实现容器的逻辑。

  单一性。由于父加载器的类型对于子加载器是可见的，所以父加载器中加载过的类型，就不会在子加载器中重复加载。但是注意，类加载器“邻居”间，同一类型仍然可以被加载多次，因为互相并不可见。 

#### 类的加载器分类

JVM支持两种类型的类加载器，分别为引导类加载器（Bootstrap ClassLoader）和自定义类加载器（User-Defined ClassLoader）。

 从概念上来讲，自定义类加载器一般指的是程序中由开发人员自定义的一类类加载器，但是Java虚拟机规范却没有这么定义，而是将所有派生于抽象类ClassLoader的类加载器都划分为自定义类加载器。  

![](https://minio.pigx.vip/oss/2022/03/05022b1443b3d38f4b958b9557cf7234.png)

- 子父类加载器的关系

   除了顶层的启动类加载器外，其余的类加载器都应当有自己的“父类”加载器。 不同类加载器看似是继承（Inheritance）关系，实际上是包含关系。在下层加载器中，包含着上层加载器的引用。  

- 具体类的加载器介绍

  **启动类加载器**（引导类加载器，Bootstrap ClassLoader）这个类加载使用C/C++语言实现的，嵌套在JVM内部。它用来加载Java的核心库（JAVA_HOME/jre/lib/rt.jar或sun.boot.class.path路径下的内容）。用于提供JVM自身需要的类。并不继承自java.lang.ClassLoader，没有父加载器。出于安全考虑，Bootstrap启动类加载器只加载包名为java、javax、sun等开头的类加载扩展类和应用程序类加载器，并指定为他们的父类加载器。 使用-XX:+TraceClassLoading参数得到。  

  **扩展类加载器**（Extension ClassLoader）Java语言编写，由sun.misc.Launcher$ExtClassLoader实现。继承于ClassLoader类,父类加载器为启动类加载器,从java.ext.dirs系统属性所指定的目录中加载类库，或从JDK的安装目录的jre/lib/ext子目录下加载类库。如果用户创建的JAR放在此目录下，也会自动由扩展类加载器加载。

  **应用程序类加载器**（系统类加载器，AppClassLoader）java语言编写，由sun.misc.Launcher$AppClassLoader实现继承于ClassLoader类父类加载器为扩展类加载器。它负责加载环境变量classpath或系统属性 java.class.path 指定路径下的类库 

  应用程序中的类加载器默认是系统类加载器。它是用户自定义类加载器的默认父加载器 ,通过ClassLoader的getSystemClassLoader()方法可以获取到该类加载器。

- 用户自定义类加载器

  在Java的日常应用程序开发中，类的加载几乎是由上述3种类加载器相互配合执行的。在必要时，我们还可以自定义类加载器，来定制类的加载方式。体现Java语言强大生命力和巨大魅力的关键因素之一便是,Java开发者可以自定义类加载器来**实现类库的动态加载**，加载源可以是本地的JAR包，也可以是网络上的远程资源。通过类加载器可以实现非常绝妙的插件机制，这方面的实际应用案例举不胜举。例如，著名的OSGI组件框架，再如Eclipse的插件机制。类加载器为应用程序提供了一种动态增加新功能的机制，这种机制无须重新打包发布应用程序就能实现。同时，自定义加载器能够实现应用隔离，例如 Tomcat，Spring等中间件和组件框架都在内部实现了自定义的加载器，并通过自定义加载器隔离不同的组件模块。这种机制比C/C++程序要好太多，想不修改C/C++程序就能为其新增功能，几乎是不可能的，仅仅一个兼容性便能阻挡住所有美好的设想。所有用户自定义类加载器通常需要继承于抽象类java.lang.ClassLoader。    

#### ClassLoader源码剖析

- ClassLoader与现有类加载器的关系

  ClassLoader与现有类加载器的关系： ClassLoader是一个抽象类。如果我们给定了一个类的二进制名称，类加载器应尝试去定位或生成构成定义类的数据。一种典型的策略是将给定的二进制名称转换为文件名，然后去文件系统中读取这个文件名所对应的class文件。   

  

- ClassLoader的主要方法

  抽象类ClassLoader的主要方法：(内部没有抽象方法)

  public final ClassLoader getParent()返回该类加载器的超类加载器 

  public Class<?> loadClass(String name) throws ClassNotFoundException加载名称为name的类，返回结果为java.lang.Class类的实例。如果找不到类，则返回 ClassNotFoundException 异常。该方法中的逻辑就是双亲委派模式的实现。 

  protected Class<?> findClass(String name) throws ClassNotFoundException查找二进制名称为name的类，返回结果为java.lang.Class类的实例。这是一个受保护的方法，JVM鼓励我们重写此方法，需要自定义加载器遵循双亲委托机制，该方法会在检查完父类加载器之后被loadClass()方法调用。 

  protected final Class<?> defineClass(String name, byte[] b, int off, int len)根据给定的字节数组b转换为Class的实例，off和len参数表示实际Class信息在byte数组中的位置和长度，其中byte数组b是ClassLoader从外部获取的。这是受保护的方法，只有在自定义ClassLoader子类中可以使用。 

  简单举例： protected final void resolveClass(Class<?> c)链接指定的一个Java类。使用该方法可以使用类的Class对象创建完成的同时也被解析。前面我们说链接阶段主要是对字节码进行验证，为类变量分配内存并设置初始值同时将字节码文件中的符号引用转换为直接引用。

   protected final Class<?> findLoadedClass(String name)查找名称为name的已经被加载过的类，返回结果为java.lang.Class类的实例。这个方法是final方法，无法被修改。

  private final ClassLoader parent;它也是一个ClassLoader的实例，这个字段所表示的ClassLoader也称为这个ClassLoader的双亲。在类加载的过程中,ClassLoader可能会将某些请求交予自己的双亲处理.

- SecureClassLoader 与 URLClassLoader

  SecureClassLoader扩展了 ClassLoader，新增了几个与使用相关的代码源(对代码源的位置及其证书的验证)和权限定义类验证(主要指对class源码的访问权限)的方法，一般我们不会直接跟这个类打交道，更多是与它的子类URLClassLoader有所关联。 前面说过，ClassLoader是一个抽象类，很多方法是空的没有实现，比如 findClass()、findResource()等。而URLClassLoader这个实现类为这些方法提供了具体的实现。并新增了URLClassPath类协助取得Class字节码流等功能。在编写自定义类加载器时，如果没有太过于复杂的需求，可以直接继承URLClassLoader类，这样就可以避免自己去编写findClass()方法及其获取字节码流的方式，使自定义类加载器编写更加简洁。  

- ExtClassLoader 与 AppClassLoader

  了解完URLClassLoader后接着看看剩余的两个类加载器，即拓展类加载器ExtClassLoader和系统类加载器AppClassLoader，这两个类都继承自URLClassLoader，是sun.misc.Launcher的静态内部类。sun.misc.Launcher主要被系统用于启动主应用程序，ExtClassLoader和AppClassLoader都是由sun.misc.Launcher创建的，其类主要类结构如下：我们发现ExtClassLoader并没有重写loadClass()方法，这足矣说明其遵循双亲委派模式，而AppClassLoader重载了loadClass()方法，但最终调用的还是父类loadClass()方法，因此依然遵守双亲委派模式。  

- Class.forName()与ClassLoader.loadClass()对比

  Class.forName()：是一个静态方法,最常用的是Class.forName(String className);根据传入的类的全限定名返回一个 Class 对象。该方法在将 Class 文件加载到内存的同时,**会执行类的初始化**。如: Class.forName("com.atguigu.java.HelloWorld"); 

  ClassLoader.loadClass()：这是一个实例方法,需要一个 ClassLoader 对象来调用该方法。该方法将 Class 文件加载到内存时,**并不会执行类的初始化**,直到这个类第一次使用时才进行初始化。该方法因为需要得到一个 ClassLoader 对象,所以可以根据需要指定使用哪个类加载器。  如：ClassLoader cl=.......;       cl.loadClass("com.atguigu.java.HelloWorld"); 


 #### 自定义类的加载器 

- 为什么要自定义类的加载器？

  隔离加载类在某些框架内进行中间件与应用的模块隔离，把类加载到不同的环境。

  比如：阿里内某容器框架通过自定义类加载器确保应用中依赖的jar包不会影响到中间件运行时使用的jar包。

  再比如：Tomcat这类Web应用服务器，内部自定义了好几种类加载器，用于隔离同一个Web应用服务器上的不同应用程序。 （类的仲裁-->类冲突）修改类加载的方式类的加载模型并非强制，除Bootstrap外，其他的加载并非一定要引入，或者根据实际情况在某个时间点进行按需进行动态加载扩展加载源比如从数据库、网络、甚至是电视机机顶盒进行加载防止源码泄漏Java代码容易被编译和篡改，可以进行编译加密。那么类加载也需要自定义，还原加密的字节码。 

- 应用场景有哪些？

  类似进程内隔离，**类加载器实际上用作不同的命名空间**，以提供类似**容器、模块化**的效果。

  例如，两个模块依赖于某个类库的不同版本，如果分别被不同的容器加载，就可以互不干扰。这个方面的集大成者是Java EE和OSGI、JPMS等框架。 应用需要从不同的数据源获取类定义信息，例如网络数据源，而不是本地文件系统。或者是需要自己操纵字节码，动态修改或者生成类型。 注意：在一般情况下，使用不同的类加载器去加载不同的功能模块，会提高应用程序的安全性。但是，如果涉及Java类型转换，则加载器反而容易产生不美好的事情。在做Java类型转换时，只有两个类型都是由同一个加载器所加载，才能进行类型转换，否则转换时会发生异常。 
  
- 两种实现方式

   用户通过定制自己的类加载器，这样可以重新定义类的加载规则，以便实现一些自定义的处理逻辑。 实现方式Java提供了抽象类java.lang.ClassLoader，所有用户自定义的类加载器都应该继承ClassLoader类。在自定义 ClassLoader 的子类时候，我们常见的会有两种做法：

  方式一：重写loadClass()方法

  方式二：重写findClass()方法 -->推荐 

   对比这两种方法本质上差不多，毕竟loadClass()也会调用findClass()，但是从逻辑上讲我们最好不要直接修改loadClass()的内部逻辑。建议的做法是只在findClass()里重写自定义类的加载方法，根据参数指定类的名字，返回对应的Class对象的引用。  

#### 相关机制

- 双亲委派机制

  类加载器用来把类加载到Java虚拟机中。

  从JDK1.2版本开始，类的加载过程采用双亲委派机制，这种机制能更好地保证Java平台的安全。

  1.定义如果一个类加载器在接到加载类的请求时，它首先不会自己尝试去加载这个类，而是把这个请求任务**委托给父类加载**器去完成，依次递归，如果父类加载器可以完成类加载任务，就成功返回。只有父类加载器无法完成此加载任务时，才自己去加载。

  2.本质规定了类加载的顺序是：引导类加载器先加载，若加载不到，由扩展类加载器加载，若还加载不到，才会由系统类加载器或自定义的类加载器进行加载。   

  - 源码分析 

    双亲委派机制在java.lang.ClassLoader.loadClass(String,boolean)接口中体现。该接口的逻辑如下：

    (1)先在当前加载器的缓存中查找有无目标类，如果有，直接返回。

    (2)判断当前加载器的父加载器是否为空，如果不为空，则调用parent.loadClass(name, false)接口进行加载。

    (3)反之，如果当前加载器的父类加载器为空，则调用findBootstrapClassOrNull(name)接口，让引导类加载器进行加载。

    (4)如果通过以上3条路径都没能成功加载，则调用findClass(name)接口进行加载。该接口最终会调用java.lang.ClassLoader接口的defineClass系列的native接口加载目标Java类。

    双亲委派的模型就隐藏在这第2和第3步中。 

    举例假设当前加载的是java.lang.Object这个类，很显然，该类属于JDK中核心得不能再核心的一个类，因此一定只能由引导类加载器进行加载。当JVM准备加载javaJang.Object时，JVM默认会使用系统类加载器去加载，按照上面4步加载的逻辑，在第1步从系统类的缓存中肯定查找不到该类，于是进入第2步。由于从系统类加载器的父加载器是扩展类加载器，于是扩展类加载器继续从第1步开始重复。由于扩展类加载器的缓存中也一定査找不到该类，因此进入第2步。扩展类的父加载器是null,因此系统调用findClass(String), 最终通过引导类加载器进行加载。 
    
  - 优势与劣势

     1.双亲委派机制优势

    避免类的重复加载，确保一个类的全局唯一性,Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关系可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。保护程序安全，防止核心API被随意篡改。 

    2.双亲委托模式的弊端

    检查类是否加载的委托过程是单向的，这个方式虽然从结构上说比较清晰，使各个ClassLoader的职责非常明确，但是同时会带来一个问题，即顶层的ClassLoader无法访问底层的ClassLoader所加载的类。 通常情况下，启动类加载器中的类为系统核心类，包括一些重要的系统接口，而在应用类加载器中，为应用类。按照这种模式，应用类访问系统类自然是没有问题，但是系统类访问应用类就会出现问题。比如在系统类中提供了一个接口，该接口需要在应用类中得以实现，该接口还绑定一个工厂方法，用于创建该接口的实例，而接口和工厂方法都在启动类加载器中。这时，就会出现该工厂方法无法创建由应用类加载器加载的应用实例的问题。 

    3.结论：**由于Java虚拟机规范并没有明确要求类加载器的加载机制一定要使用双亲委派模型**，只是建议采用这种方式而已。比如在Tomcat中，类加载器所采用的加载机制就和传统的双亲委派模型有一定区别，当缺省的类加载器接收到一个类的加载任务时，首先会由它自行加载，当它加载失败时，才会将类的加载任务委派给它的超类加载器去执行，这同时也是Servlet规范推荐的一种做法。 

  - 破坏双亲委派机制及举例

    这里，我们使用了“被破坏”这个词来形容上述不符合双亲委派模型原则的行为，但这里“被破坏”并**不一定是带有贬义**的。只要有明确的目的和充分的理由，突破旧有原则无疑是一种创新。 正如：破坏双亲委派机制3的OSGi中的类加载器的设计不符合传统的双亲委派的类加载器架构，且业界对其为了实现热部署而带来的额外的高复杂度还存在不少争议，但对这方面有了解的技术人员基本还是能达成一个共识，认为OSGi中对类加载器的运用是值得学习的，完全弄懂了OSGi的实现，就算是掌握了类加载器的精粹。

    - 破坏双亲委派机制1

      双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。 

      在Java的世界中大部分的类加载器都遵循这个模型，但也有例外的情况，直到Java模块化出现为止，双亲委派模型主要出现过3次较大规模“被破坏”的情况。

       第一次破坏双亲委派机制：双亲委派模型的第一次“被破坏”其实发生在双亲委派模型出现之前——即JDK 1.2面世以前的“远古”时代。由于双亲委派模型在JDK 1.2之后才被引入，但是类加载器的概念和抽象类java.lang.ClassLoader则在Java的第一个版本中就已经存在，面对已经存在的用户自定义类加载器的代码，Java设计者们引入双亲委派模型时不得不做出一些妥协，为了兼容这些已有代码，无法再以技术手段避免loadClass()被子类覆盖的可能性，只能在JDK1.2之后的java.lang.ClassLoader中添加一个新的protected方法findClass()，并引导用户编写的类加载逻辑时尽可能去重写这个方法，而不是在loadClass()中编写代码。上节我们已经分析过loadClass()方法，双亲委派的具体逻辑就实现在这里面，按照loadClass()方法的逻辑，如果父类加载失败，会自动调用自己的findClass()方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。 

    - 破坏双亲委派机制2

      第二次破坏双亲委派机制：线程上下文类加载器 

      双亲委派模型的第二次“被破坏”是由这个模型自身的缺陷导致的，双亲委派很好地解决了各个类加载器协作时基础类型的一致性问题（越基础的类由越上层的加载器进行加载），基础类型之所以被称为“基础”，是因为它们总是作为被用户代码继承、调用的API存在，但程序设计往往没有绝对不变的完美规则，**如果有基础类型又要调用回用户的代码，那该怎么办呢？** 这并非是不可能出现的事情，一个典型的例子便是**JNDI服务**，JNDI现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar的），肯定属于Java中很基础的类型了。但JNDI存在的目的就是对资源进行查找和集中管理，它需要调用由其他厂商实现并部署在应用程序的ClassPath下的JNDI服务提供者接口（Service Provider Interface，SPI）的代码，现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？

      （SPI:在Java平台中，通常把核心类rt.jar中提供外部服务、可由应用层自行实现的接口称为SPI） 为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：**线程上下文类加载器**（Thread Context ClassLoader）。这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置，如果创建线程时还未设置，它将会从父线程中继承一个，如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。 有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。**Java中涉及SPI的加载基本上都采用这种方式来完成**，例如JNDI、JDBC、JCE、JAXB和JBI等。**不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。** 默认上下文加载器就是应用类加载器，这样以上下文加载器为中介，使得启动类加载器中的代码也可以访问应用类加载器中的类。    

    - 破坏双亲委派机制3

      第三次破坏双亲委派机制：双亲委派模型的第三次“被破坏”是由于用户对程序动态性的追求而导致的。

      如：代码热替换（Hot Swap）、模块热部署（Hot Deployment）等 IBM公司主导的JSR-291（即OSGi R4.2）**实现模块化热部署的关键是它自定义的类加载器机制的实现**，**每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。**在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。 当收到类加载请求时，OSGi将按照下面的顺序进行类搜索：

      1）将以java.*开头的类，委派给父类加载器加载。

      2）否则，将委派列表名单内的类，委派给父类加载器加载。

      3）否则，将Import列表中的类，委派给Export这个类的Bundle的类加载器加载。

      4）否则，查找当前Bundle的ClassPath，使用自己的类加载器加载。

      5）否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载。

      6）否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。7）否则，类查找失败。说明：只有开头两点仍然符合双亲委派模型的原则，其余的类查找都是在平级的类加载器中进行的   

  - 几个问题

    1.既然 Tomcat 不遵循双亲委派机制，那么如果我自己定义一个恶意的HashMap，会不会有风险呢？(阿里面试问题)

    答： 显然不会有风险，如果有，Tomcat都运行这么多年了，那能不改进吗？ tomcat不遵循双亲委派机制，只是自定义的classLoader顺序不同，但顶层还是相同的，还是要去顶层请求classloader。 

    2.我们思考一下：Tomcat是个web容器， 那么它要解决什么问题？

     1. 一个web容器可能需要部署两个应用程序，不同的应用程序可能会依赖同一个第三方类库的不同版本，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。

     2.  部署在同一个web容器中相同的类库相同的版本可以共享。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机，这是扯淡的。 

     3. web容器也有自己依赖的类库，不能于应用程序的类库混淆。基于安全考虑，应该让容器的类库和程序的类库隔离开来。 

     4. web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情，否则要你何用？ 所以，web容器需要支持 jsp 修改后不用重启。 

    3.Tomcat 如果使用默认的类加载机制行不行？
    
    答案是不行的。为什么？
    
    我们看:
    
    第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加载器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。
    
    第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证唯一性。
    
    第三个问题和第一个问题一样。我们再看第四个问题，我们想我们要怎么实现jsp文件的热替换，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？**我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。** 
    
    4.如果tomcat 的 Common ClassLoader 想加载 WebApp ClassLoader 中的类，该怎么办？看了前面的关于破坏双亲委派模型的内容，我们心里有数了，**我们可以使用线程上下文类加载器实现，使用线程上下文加载器，可以让父类加载器请求子类加载器去完成类加载的动作**。
    
     5.为什么java文件放在Eclipse/IDEA中的src文件夹下会优先jar包中的class?
    
    tomcat类加载机制的理解，就不难明白。因为Eclipse/IDEA中的src文件夹中的文件java以及webContent中的JSP都会在tomcat启动时，被编译成class文件放在 WEB-INF/class 中。而Eclipse/IDEA外部引用的jar包，则相当于放在 WEB-INF/lib 中。因此肯定是 java文件或者JSP文件编译出的class优先加载。 
  
- 沙箱安全机制

  沙箱安全机制保证程序安全保护Java原生的JDK代码 Java安全模型的核心就是Java沙箱（sandbox）。

  什么是沙箱？沙箱是一个限制程序运行的环境。 **沙箱机制就是将Java代码限定在虚拟机（JVM）特定的运行范围中，并且严格限制代码对本地系统资源访问。**通过这样的措施来保证对代码的有限隔离，防止对本地系统造成破坏。 沙箱主要限制系统资源访问，那系统资源包括什么？CPU、内存、文件系统、网络。不同级别的沙箱对这些资源访问的限制也可以不一样。 所有的Java程序运行都可以指定沙箱，可以定制安全策略。  

#### JDK9中类加载结构的新变化

为了保证兼容性，JDK 9没有从根本上改变三层类加载器架构和双亲委派模型，但为了模块化系统的顺利运行，仍然发生了一些值得被注意的变动。 

1. 扩展机制被移除，扩展类加载器由于向后兼容性的原因被保留，不过被重命名为平台类加载器（platform class loader）。可以通过ClassLoader的新方法getPlatformClassLoader()来获取。 JDK 9 时基于模块化进行构建（原来的 rt.jar 和 tools.jar 被拆分成数十个 JMOD 文件），其中的 Java 类库就已天然地满足了可扩展的需求，那自然无须再保留 <JAVA_HOME>\lib\ext 目录，此前使用这个目录或者 java.ext.dirs 系统变量来扩展 JDK 功能的机制已经没有继续存在的价值了。
2.   平台类加载器和应用程序类加载器都不再继承自 java.net.URLClassLoader。现在启动类加载器、平台类加载器、应用程序类加载器全都继承于 jdk.internal.loader.BuiltinClassLoader。如果有程序直接依赖了这种继承关系，或者依赖了 URLClassLoader 类的特定方法，那代码很可能会在 JDK 9 及更高版本的 JDK 中崩溃。 
3.  在Java 9中，类加载器有了名称。该名称在构造方法中指定，可以通过getName()方法来获取。平台类加载器的名称是platform，应用类加载器的名称是app。类加载器的名称在调试与类加载器相关的问题时会非常有用。
4.   启动类加载器现在是在jvm内部和java类库共同协作实现的类加载器（以前是 C++实现），但为了与之前代码兼容，在获取启动类加载器的场景中仍然会返回null，而不会得到BootClassLoader实例。
5.   类加载的委派关系也发生了变动。当平台及应用程序类加载器收到类加载请求，在委派给父加载器加载前，要先判断该类是否能够归属到某一个系统模块中，如果可以找到这样的归属关系，就要优先委派给负责那个模块的加载器完成加载。   



### 运行时内存篇

哪些内存结构与线程一一对应？ 

 Java虚拟机定义了若干种程序运行期间会使用到的运行时数据区，其中有一些会随着虚拟机启动而创建，随着虚拟机退出而销毁。另外一些则是与线程一一对应的，这些与线程对应的数据区域会随着线程开始和结束而创建和销毁。

https://www.cnblogs.com/misterchaos/p/memory-management-in-jvm.html

#### 程序计数器

**为了保证程序(在操作系统中理解为进程)能够连续地执行下去，CPU必须具有某些手段来确定下一条指令的地址。而程序计数器正是起到这种作用，所以通常又称为指令计数器**。在程序开始执行前，必须将它的起始地址，即程序的一条指令所在的内存单元地址送入PC，因此程序计数器（PC）的内容即是从内存提取的第一条指令的地址。当执行指令时，CPU将自动修改PC的内容，即每执行一条指令PC增加一个量，这个量等于指令所含的字节数，以便使其保持的总是将要执行的下一条指令的地址。由于大多数指令都是按顺序来执行的，所以修改的过程通常只是简单的对PC加1。 当程序转移时，转移指令执行的最终结果就是要改变PC的值，此PC值就是转去的地址，以此实现转移。有些机器中也称PC为指令指针IP（Instruction Pointer）。  

##### 基本特征

 JVM中的程序计数寄存器（Program Counter Register）中， Register 的命名源于CPU的寄存器，寄存器存储指令相关的现场信息。 CPU只有把数据装载到寄存器才能够运行。 这里，并非是广义上所指的物理寄存器，或许将其翻译为PC计数器（或指令计数器）会更加贴切(也称为程序钩子) ，并且也不容易引起一些不必要的误会。**JVM中的PC寄存器是对物理PC寄存器的一种抽象模拟。  它是一块很小的内存空间，几乎可以忽略不记。也是运行速度最快的存储区域。不会随着程序的运行需要更大的空间。在JVM规范中，每个线程都有它自己的程序计数器，是线程私有的，生命周期与线程的生命周期保持一致。它是唯一一个在Java 虚拟机规范中没有规定任何OutOtMemoryError 情况的区域。**

##### PC寄存器存储字节码指令地址有什么用？(为什么使用PC寄存器记录当前线程的执行地址呢？)

  因为CPU需要不停的切换各个线程，这时候切换回来以后，就得知道接着从哪开始继续执行。 JVM的字节码解释器就需要通过改变PC寄存器的值来明确下一条应该执行什么样的字节码指令。   

##### PC寄存器为什么被设定为线程私有的？

 我们都知道所谓的多线程在一个特定的时间段内只会执行其中某一个线程的方法，CPU会不停地做任务切换，这样必然导致经常中断或恢复，如何保证分毫无差呢？为了能够准确地记录各个线程正在执行的当前字节码指令地址，最好的办法自然是为每一个线程都分配一个PC寄存器，这样一来各个线程之间便可以进行独立计算，从而不会出现相互干扰的情况。  



#### 虚拟机栈

 有不少Java开发人员一提到Java内存结构，就会非常粗粒度地将JVM中的内存区理解为仅有Java堆(heap)和Java栈(stack)？ Java虚拟机栈是什么？Java虚拟机栈（Java Virtual Machine Stack），早期也叫Java栈。每个线程在创建时都会创建一个虚拟机栈，其内部保存一个个的栈帧（Stack Frame），对应着一次次的Java方法调用。是线程私有的 生命周期生命周期和线程一致。 特点栈是一种快速有效的分配存储方式，访问速度仅次于程序计数器。  

**如何理解栈管运行，堆管存储？** 

作用主管Java程序的运行，它保存方法的局部变量(8种基本数据类型、对象的引用地址)、部分结果，并参与方法的调用和返回。局部变量 vs 成员变量(或属性)基本数据变量 vs 引用类型变量（类、数组、接口） 即：栈解决程序的运行问题，即程序如何执行，或者说如何处理数据。堆解决的是数据存储的问题，即数据怎么放、放在哪儿。 

**栈存在GC吗**

不存在GC ; 存在OOM 

**可能抛出的异常**

 StackOverFlowError？OutOfMemoryError？ Java 虚拟机规范**允许Java栈的大小是动态的或者是固定不变的**。如果采用固定大小的Java虚拟机栈，那每一个线程的Java虚拟机栈容量可以在线程创建的时候独立选定。如果线程请求分配的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。如果Java虚拟机栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的虚拟机栈，那Java虚拟机将会抛出—个 OutOfMemoryError 异常。  

**如何设置栈大小**

-Xss size (即：-XX:ThreadStackSize)一般默认为512k-1024k，取决于操作系统。栈的大小直接决定了函数调用的最大可达深度。  

**栈的单位：栈帧（Stack Frame）**

- 方法和栈帧的关系？

   在这个线程上正在执行的每个方法都各自对应一个栈帧（Stack Frame）。栈帧是一个内存区块，是一个数据集，维系着方法执行过程中的各种数据信息。  

- 栈的FILO原理

   JVM直接对Java栈的操作只有两个：每个方法执行，伴随着进栈(入栈、压栈)执行结束后的出栈工作遵循“先进后出”/“后进先出”原则  

**栈桢内部结构**

- 局部变量表(local variables)

  局部变量表也被称之为**局部变量数组或本地变量表定义为一个数字数组**，主要用于存储**方法参数**和定义在方法体内的**局部变量**，这些数据类型包括各类基本数据类型(8种)、对象引用（reference），以及returnAddress类型。局部变量表所需的容量大小是在编译期确定下来的，并保存在方法的Code属性的maximum local variables数据项中。在方法运行期间是不会改变局部变量表的大小的。**方法嵌套调用的次数由栈的大小决定。一般来说，栈越大，方法嵌套调用次数越多。**对一个函数而言，它的参数和局部变量越多，使得局部变量表膨胀，它的栈帧就越大，以满足方法调用所需传递的信息增大的需求。进而函数调用就会占用更多的栈空间，导致其嵌套调用次数就会减少。局部变量表中的变量只在当前方法调用中有效。在方法执行时，虚拟机通过使用局部变量表完成参数值到参数变量列表的传递过程。当方法调用结束后，随着方法栈帧的销毁，局部变量表也会随之销毁。  

  参数值的存放总是在局部变量数组的index为0开始，到数组长度-1的索引结束。局部变量表，最基本的存储单元是Slot（变量槽）在局部变量表里，32位以内的类型只占用一个slot（包括returnAddress类型），64位的类型（long和double)占用两个slot。byte 、short 、char 在存储前被转换为int，boolean 也被转换为int，0 表示false ，非0 表示true。long 和double 则占据两个Slot。JVM会为局部变量表中的每一个Slot都分配一个访问索引，通过这个索引即可成功访问到局部变量表中指定的局部变量值当一个实例方法被调用的时候，它的方法参数和方法体内部定义的局部变量将会按照顺序被复制到局部变量表中的每一个Slot上如果需要访问局部变量表中一个64bit的局部变量值时，只需要使用前一个索引即可。(比如：访问long或double类型变量）如果当前帧是由构造方法或者实例方法创建的，那么该对象引用this将会存放在index为0的slot处，其余的参数按照参数表顺序继续排列。   

  **栈帧中的局部变量表中的槽位是可以重用的，**如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能会复用过期局部变量的槽位，从而达到节省资源的目的。 

  参数表分配完毕之后，再根据方法体内定义的变量的顺序和作用域分配。我们知道类变量表有两次初始化的机会，第一次是在“准备阶段”，执行系统初始化，对类变量设置零值，另一次则是在“初始化”阶段，赋予程序员在代码中定义的初始值。和类变量初始化不同的是，局部变量表不存在系统初始化的过程，这意味着一旦定义了局部变量则必须人为的初始化，否则无法使用。 public void test() {   int i;   System.out.println(i); }这样的代码是错误的，没有赋值不能够使用。  

  局部变量表中的变量也是重要的垃圾回收根节点，只要被局部变量表中直接或间接引用的对象都不会被回收。  

- 操作数栈（Operand Stack）

  我们说Java虚拟机的解释引擎是基于栈的执行引擎，其中的栈指的就是**操作数栈**。每一个独立的栈帧中除了包含**局部变量表以**外，还包含**一个后进先出（Last-In-First-Out）的操作数栈**，也可以称之为表达式栈（Expression Stack）。操作数栈就是JVM执行引擎的一个工作区，当一个方法刚开始执行的时候，一个新的栈帧也会随之被创建出来，这个方法的操作数栈是空的。每一个操作数栈都会拥有一个明确的栈深度用于存储数值，其所需的最大深度在编译期就定义好了，保存在方法的Code属性中，为max_stack的值。栈中的任何一个元素都是可以任意的Java数据类型。32bit的类型占用一个栈单位深度,64bit的类型占用两个栈单位深度操作数栈，在方法执行过程中，根据字节码指令，并非采用访问索引的方式来进行数据访问的，而是只能通过标准的入栈（push）和出栈（pop）操作，往栈中写入数据或提取数据来完成一次数据访问。某些字节码指令将值压入操作数栈，其余的字节码指令将操作数取出栈。使用它们后再把结果压入栈。比如：执行复制、交换、求和等操作如果被调用的方法带有返回值的话，其返回值将会被压入当前栈帧的操作数栈中，并更新PC寄存器中下一条需要执行的字节码指令。  

  前面提过，基于栈式架构的虚拟机所使用的零地址指令更加紧凑，但完成一项操作的时候必然需要使用更多的入栈和出栈指令，这同时也就意味着将需要更多的指令分派（instruction dispatch）次数和内存读/写次数。 由于操作数是存储在内存中的，因此频繁地执行内存读/写操作必然会影响执行速度。为了解决这个问题，HotSpot JVM的设计者们提出了栈顶缓存（ToS，Top-of-Stack Cashing）技术，将栈顶元素全部缓存在物理CPU的寄存器中，以此降低对内存的读/写次数，提升执行引擎的执行效率。
  
- 动态链接(或指向运行时常量池的方法引用)

  **每一个栈帧内部都包含一个指向运行时常量池中该栈帧所属方法的引用。**包含这个引用的目的就是为了支持当前方法的代码能够实现动态链接（Dynamic Linking）。比如：invokedynamic指令 在Java源文件被编译到字节码文件中时，所有的变量和方法引用都作为符号引用（Symbolic Reference）保存在class文件的常量池里。比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些符号引用转换为调用方法的直接引用。 public void testGetSum(){    int i = getSum();  int j = 10;}   

  **为什么需要常量池呢？**

  常量池的作用，就是为了提供一些符号和常量，便于指令的识别。

- 方法返回地址

  存放调用该方法的pc寄存器的值。 一个方法的结束，有两种方式：正常执行完成出现未处理的异常，非正常退出 无论通过哪种方式退出，在方法退出后都返回到该方法被调用的位置。方法正常退出时，调用者的pc计数器的值作为返回地址，即调用该方法的指令的下一条指令的地址。而通过异常退出的，返回地址是要通过异常表来确定，栈帧中一般不会保存这部分信息。    

- 一些附加信息

   栈帧中还允许携带与Java虚拟机实现相关的一些附加信息。例如，对程序调试提供支持的信息。 



**问题小结与拓展**

 问题一：栈溢出的情况?

栈溢出:StackOverflowError;

举个简单的例子:在main方法中调用main方法,就会不断压栈执行,直到栈溢出;栈的大小可以是固定大小的,也可以是动态变化（动态扩展）的。如果是固定的,可以通过-Xss设置栈的大小;如果是动态变化的,当栈大小到达了整个内存空间不足了,就是抛出OutOfMemory异常(java.lang.OutOfMemoryError) 

问题二：调整栈大小,就能保证不出现溢出吗?

不能。因为调整栈大小,只会减少出现溢出的可能,栈大小不是可以无限扩大的,所以不能保证不出现溢出

问题三：分配的栈内存越大越好吗?

不是,因为增加栈大小，会造成每个线程的栈都变的很大,使得一定的栈空间下,能创建的线程数量会变小

问题四：垃圾回收是否会涉及到虚拟机栈?

不会;

垃圾回收只会涉及到方法区和堆中,方法区和堆也会存在溢出的可能;

程序计数器,只记录运行下一行的地址,不存在溢出和垃圾回收;

虚拟机栈和本地方法栈,都是只涉及压栈和出栈,可能存在栈溢出,不存在垃圾回收。

 问题五：方法中定义的局部变量是否线程安全?

具体问题具体分析,见分析代码:

 

![](https://minio.pigx.vip/oss/2022/03/ef1f4331cb9660064a9dc147ac7aa829.png)

![](https://minio.pigx.vip/oss/2022/03/cf32213fbab88f0fdc6d49342895f1ef.png)

![](https://minio.pigx.vip/oss/2022/03/57a8c4d1fdc9714b3ab692ac7ccb8037.png)



#### 本地方法接口与本地方法栈

**什么是本地方法?**

简单地讲，**一个Native Method就是一个Java调用非Java代码的接口**。一个Native Method是这样一个Java方法：该方法的实现由非Java语言实现，比如C。这个特征并非Java所特有，很多其它的编程语言都有这一机制，比如在C++中，你可以用extern "C"告知C++编译器去调用一个C的函数。 "A native method is a Java method whose implementation is provided by non-java code." 在定义一个native method时，并不提供实现体（有些像定义一个Java interface），因为其实现体是由非java语言在外面实现的。 本地接口的作用是融合不同的编程语言为Java所用，它的初衷是融合 C/C++程序。   

**为什么要使用Native Method？**

Java使用起来非常方便，然而有些层次的任务用Java实现起来不容易，或者我们对程序的效率很在意时，问题就来了。 

与Java环境外交互：有时Java应用需要与Java外面的环境交互，这是本地方法存在的主要原因。你可以想想Java需要与一些底层系统，如操作系统或某些硬件交换信息时的情况。本地方法正是这样一种交流机制：它为我们提供了一个非常简洁的接口，而且我们无需去了解Java应用之外的繁琐的细节。

 与操作系统交互：JVM支持着Java语言本身和运行时库，它是Java程序赖以生存的平台，它由一个解释器（解释字节码）和一些连接到本地代码的库组成。然而不管怎样，它毕竟不是一个完整的系统，它经常依赖于一些底层系统的支持。这些底层系统常常是强大的操作系统。通过使用本地方法，我们得以用Java实现了jre的与底层系统的交互，甚至JVM的一些部分就是用C写的。还有，如果我们要使用一些Java语言本身没有提供封装的操作系统的特性时，我们也需要使用本地方法。 Sun's JavaSun的解释器是用C实现的，这使得它能像一些普通的C一样与外部交互。jre大部分是用Java实现的，它也通过一些本地方法与外界交互。例如：类java.lang.Thread 的 setPriority()方法是用Java实现的，但是它实现调用的是该类里的本地方法setPriority0()。这个本地方法是用C实现的，并被植入JVM内部，在Windows 95的平台上，这个本地方法最终将调用Win32 SetPriority() API。这是一个本地方法的具体实现由JVM直接提供，更多的情况是本地方法由外部的动态链接库（external dynamic link library）提供，然后被JVM调用。  

**本地方法栈**

**Java虚拟机栈用于管理Java方法的调用，而本地方法栈用于管理本地方法的调用。**本地方法栈，也是**线程私有**的。允许被实现成固定或者是可动态扩展的内存大小。（在内存溢出方面是相同的）如果线程请求分配的栈容量超过本地方法栈允许的最大容量，Java虚拟机将会抛出一个 StackOverflowError 异常。如果本地方法栈可以动态扩展，并且在尝试扩展的时候无法申请到足够的内存，或者在创建新的线程时没有足够的内存去创建对应的本地方法栈，那么Java虚拟机将会抛出一个 OutOfMemoryError 异常。本地方法是使用C语言实现的。它的具体做法是Native Method Stack中登记native方法，在Execution Engine 执行时加载本地方法库。  当某个线程调用一个本地方法时，它就进入了一个全新的并且不再受虚拟机限制的世界。它和虚拟机拥有同样的权限。本地方法可以通过本地方法接口来访问虚拟机内部的运行时数据区。它甚至可以直接使用本地处理器中的寄存器直接从本地内存的堆中分配任意数量的内存。 并不是所有的JVM都支持本地方法。因为Java虚拟机规范并没有明确要求本地方法栈的使用语言、具体实现方式、数据结构等。如果JVM产品不打算支持native方法，也可以无需实现本地方法栈。   

#### 堆

**一个JVM实例只存在一个堆内存，堆也是Java内存管理的核心区域。Java 堆区在JVM启动的时候即被创建，其空间大小也就确定了。是JVM管理的最大一块内存空间。堆内存的大小是可以调节的。《Java虚拟机规范》规定，堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。 堆，是GC ( Garbage Collection，垃圾收集器）执行垃圾回收的重点区域。在方法结束后，堆中的对象不会马上被移除，仅仅在垃圾收集的时候才会被移除。**  

- 对象都分配在堆上？

   《Java虚拟机规范》中对Java堆的描述是：所有的对象实例以及数组都应当在运行时分配在堆上。（The heap is the run-time data area from which memory for all class instances and arrays is allocated ) 数组和对象可能永远不会存储在栈上，因为栈帧中保存引用，这个引用指向对象或者数组在堆中的位置。 我要说的是：“几乎”所有的对象实例都在这里分配内存。 

- 所有的线程都共享堆？

   所有的线程共享Java堆，在这里还可以划分线程私有的缓冲区（Thread Local Allocation Buffer, TLAB)。 

**堆的内部结构**

现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为： Java 7及之前堆内存逻辑上分为三部分：新生区+养老区+永久区

 Young Generation Space  新生区   Young/New又被划分为Eden区和Survivor区

Tenure generation space  养老区  

 Old/TenurePermanent Space      永久区

  Java 8及之后堆内存逻辑上分为三部分：新生区+养老区+元空间

Young Generation Space   新生区   Young/New又被划分为Eden区和Survivor区

Tenure generation space  养老区  

 Old/TenureMeta Space         元空间   Meta   约定：新生区<=>新生代<=>年轻代 养老区<=>老年区<=>老年代 永久区<=>永久代  

- 年轻代与老年代

   存储在JVM中的Java对象可以被划分为两类：

  一类是生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速。

  另外一类对象的生命周期却非常长，在某些极端的情况下还能够与JVM的生命周期保持一致。

  Java堆区进一步细分的话，可以划分为年轻代（YoungGen）和老年代（OldGen）其中年轻代又可以划分为Eden空间、Survivor0空间和Survivor1空间（有时也叫做from区、to区）。 几乎所有的Java对象都是在Eden区被new出来的。绝大部分的Java对象的销毁都在新生代进行了。IBM 公司的专门研究表明，新生代中 80% 的对象都是“朝生夕死”的。



**如何设置堆内存大小？**

Java堆区用于存储Java对象实例，那么堆的大小在JVM启动时就已经设定好了，大家可以通过选项”-Xmx”和”-Xms”来进行设置。

“-Xms”用于表示堆区的起始内存，等价于-XX:InitialHeapSize“-Xmx”则用于表示堆区的最大内存，等价于-XX:MaxHeapSize 一旦堆区中的内存大小超过“-Xmx”所指定的最大内存时，将会抛出OutOfMemoryError:heap异常。 

通常会将 -Xms 和 -Xmx两个参数配置相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小，从而提高性能。

heap默认最大值计算方式：如果物理内存少于192M,那么heap最大值为物理内存的一半。如果物理内存大于等于1G，那么heap的最大值为物理内存的1/4。heap默认最小值计算方式：最少不得少于8M，如果物理内存大于等于1G，那么默认值为物理内存的1/64，即1024/64=16M。最小堆内存在jvm启动的时候就会被初始化。 #############关于堆空间的大小，我从官网取下来说明：On Oracle Solaris 7 and Oracle Solaris 8 SPARC platforms, the upper limit for this value is approximately 4,000 MB minus overhead amounts. On Oracle Solaris 2.6 and x86 platforms, the upper limit is approximately 2,000 MB minus overhead amounts. On Linux platforms, the upper limit is approximately 2,000 MB minus overhead amounts. 另：对于32位虚拟机，如果物理内存等于4G，那么堆内存可以达到1G。对于64位虚拟机，如果物理内存为128G，那么heap最多可以达到32G。 